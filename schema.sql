-- Podstawowy schemat bazy dla aplikacji rezerwacji świetlic.
-- Uruchom w Supabase przed skryptami dodatkowymi (np. supabase/caretaker_access.sql).

set search_path = public;

create extension if not exists "pgcrypto";

-- Funkcja wspierająca aktualizację kolumn updated_at.
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;


-- Funkcja zwracająca identyfikator opiekuna na podstawie nagłówków żądania.
create or replace function public.current_caretaker_id()
returns uuid
language plpgsql
stable
as $$
declare
  header text;
  uid uuid;
begin
  uid := auth.uid();
  if uid is not null then
    return uid;
  end if;

  header := nullif(current_setting('request.header.x-caretaker-id', true), '');
  if header is not null then
    begin
      return header::uuid;
    exception when others then
      return null;
    end;
  end if;

  return null;
end;
$$;

grant execute on function public.current_caretaker_id() to anon, authenticated;


-- Tabela obiektów (świetlic).
create table if not exists public.facilities (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  postal_code text,
  city text,
  address_line1 text,
  address_line2 text,
  capacity integer,
  price_per_hour numeric(12,2),
  price_per_day numeric(12,2),
  price_list_url text,
  rental_rules_url text,
  lat numeric(10,6),
  lng numeric(10,6),
  description text,
  image_urls text,
  caretaker_instructions text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists facilities_name_idx
  on public.facilities (lower(name));

create index if not exists facilities_city_idx
  on public.facilities (lower(city));

drop trigger if exists facilities_set_updated_at on public.facilities;
create trigger facilities_set_updated_at
before update on public.facilities
for each row execute function public.set_updated_at();

-- Widok z danymi świetlic udostępniany publicznie.
create or replace view public.public_facilities as
select
  f.id,
  f.name,
  f.postal_code,
  f.city,
  f.address_line1,
  f.address_line2,
  f.capacity,
  f.price_per_hour,
  f.price_per_day,
  f.price_list_url,
  f.rental_rules_url,
  f.lat,
  f.lng,
  f.description,
  f.image_urls,
  f.caretaker_instructions,
  f.created_at,
  f.updated_at
from public.facilities f;

grant select on table public.public_facilities to anon, authenticated;

-- Słownik udogodnień.
create table if not exists public.amenities (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  description text,
  is_active boolean not null default true,
  order_index integer not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists amenities_active_order_idx
  on public.amenities (is_active desc, order_index, lower(name));

drop trigger if exists amenities_set_updated_at on public.amenities;
create trigger amenities_set_updated_at
before update on public.amenities
for each row execute function public.set_updated_at();

-- Widok słownika udogodnień dostępny publicznie.
create or replace view public.public_amenities as
select
  a.id,
  a.name,
  a.description,
  a.order_index
from public.amenities a
where a.is_active;

grant select on table public.public_amenities to anon, authenticated;

-- Przypisanie udogodnień do świetlic.
create table if not exists public.facility_amenities (
  facility_id uuid not null references public.facilities(id) on delete cascade,
  amenity_id uuid not null references public.amenities(id) on delete cascade,
  assigned_at timestamptz not null default now(),
  primary key (facility_id, amenity_id)
);

create index if not exists facility_amenities_amenity_idx
  on public.facility_amenities (amenity_id);

-- Widok powiązań świetlic z udogodnieniami dla użytkowników publicznych.
create or replace view public.public_facility_amenities as
select
  fa.facility_id,
  fa.amenity_id
from public.facility_amenities fa
  join public.amenities a on a.id = fa.amenity_id
where coalesce(a.is_active, true);

grant select on table public.public_facility_amenities to anon, authenticated;

-- Lista kontrolna przekazania świetlicy.
create table if not exists public.facility_checklist_items (
  id bigint generated by default as identity primary key,
  facility_id uuid not null references public.facilities(id) on delete cascade,
  phase text not null check (phase in ('handover', 'return')),
  title text not null,
  description text,
  is_required boolean not null default true,
  order_index integer not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists facility_checklist_items_facility_phase_idx
  on public.facility_checklist_items (facility_id, phase, order_index, id);

drop function if exists public.set_facility_checklist_items_updated_at();
create or replace function public.set_facility_checklist_items_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists facility_checklist_items_set_updated_at on public.facility_checklist_items;
create trigger facility_checklist_items_set_updated_at
before update on public.facility_checklist_items
for each row execute function public.set_facility_checklist_items_updated_at();
-- Dane opiekunów świetlic.
create table if not exists public.caretakers (
  id uuid primary key references auth.users (id) on delete cascade,
  first_name text not null,
  last_name_or_company text not null,
  phone text not null,
  email text not null,
  login text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create unique index if not exists caretakers_email_unique
  on public.caretakers (lower(email));

create unique index if not exists caretakers_login_unique
  on public.caretakers (lower(login));

drop trigger if exists caretakers_set_updated_at on public.caretakers;
create trigger caretakers_set_updated_at
before update on public.caretakers
for each row execute function public.set_updated_at();

-- Funkcja umożliwiająca bezpieczne tworzenie profilu opiekuna
-- bez konieczności posiadania aktywnej sesji użytkownika.
create or replace function public.create_caretaker_profile(
  p_id uuid,
  p_first_name text,
  p_last_name_or_company text,
  p_phone text,
  p_email text,
  p_login text
)
returns public.caretakers
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user auth.users%rowtype;
  v_result public.caretakers%rowtype;
begin
  if p_id is null then
    raise exception using message = 'USER_ID_REQUIRED';
  end if;

  select *
  into v_user
  from auth.users
  where id = p_id;

  if not found then
    raise exception using message = 'USER_NOT_FOUND';
  end if;

  if coalesce(lower(v_user.email), '') <> coalesce(lower(p_email), '') then
    raise exception using message = 'EMAIL_MISMATCH';
  end if;

  insert into public.caretakers as c (id, first_name, last_name_or_company, phone, email, login)
  values (
    p_id,
    trim(both from coalesce(p_first_name, '')),
    trim(both from coalesce(p_last_name_or_company, '')),
    trim(both from coalesce(p_phone, '')),
    trim(both from coalesce(p_email, '')),
    trim(both from coalesce(p_login, ''))
  )
  on conflict (id) do update
    set first_name = excluded.first_name,
        last_name_or_company = excluded.last_name_or_company,
        phone = excluded.phone,
        email = excluded.email,
        login = excluded.login,
        updated_at = now()
  returning c.* into v_result;

  return v_result;
end;
$$;

grant execute on function public.create_caretaker_profile(
  uuid,
  text,
  text,
  text,
  text,
  text
) to anon, authenticated;

-- Powiązania świetlic z opiekunami.
create table if not exists public.facility_caretakers (
  caretaker_id uuid not null references public.caretakers(id) on delete cascade,
  facility_id uuid not null references public.facilities(id) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (caretaker_id, facility_id)
);

create index if not exists facility_caretakers_facility_idx
  on public.facility_caretakers (facility_id);

create index if not exists facility_caretakers_caretaker_idx
  on public.facility_caretakers (caretaker_id);

-- Funkcja pomocnicza sprawdzająca istnienie opiekuna.
create or replace function public.caretaker_exists(p_caretaker_id uuid)
returns boolean
language sql
security definer
set search_path = public
as $$
  select exists (
    select 1
    from public.caretakers c
    where c.id = p_caretaker_id
  );
$$;

grant execute on function public.caretaker_exists(uuid) to anon, authenticated;

-- Konfiguracja polityk RLS dla opiekunów i przypisań.
alter table public.caretakers enable row level security;
alter table public.facility_caretakers enable row level security;

drop policy if exists "Allow anonymous caretakers insert" on public.caretakers;
create policy "Allow anonymous caretakers insert"
  on public.caretakers
  for insert
  to authenticated
  with check (
    auth.uid() = id
  );

drop policy if exists "Caretaker can read self" on public.caretakers;
create policy "Caretaker can read self"
  on public.caretakers
  for select
  to authenticated
  using (
    auth.uid() = id
  );

drop policy if exists "Caretaker can update self" on public.caretakers;
create policy "Caretaker can update self"
  on public.caretakers
  for update
  to authenticated
  using (
    auth.uid() = id
  )
  with check (
    auth.uid() = id
  );

drop policy if exists "Caretaker can see assigned facilities" on public.facility_caretakers;
create policy "Caretaker can see assigned facilities"
  on public.facility_caretakers
  for select
  to authenticated
  using (
    public.current_caretaker_id() = caretaker_id
  );

drop policy if exists "Caretaker can assign self" on public.facility_caretakers;
create policy "Caretaker can assign self"
  on public.facility_caretakers
  for insert
  to authenticated
  with check (
    public.current_caretaker_id() = caretaker_id
  );

drop policy if exists "Caretaker can unassign self" on public.facility_caretakers;
create policy "Caretaker can unassign self"
  on public.facility_caretakers
  for delete
  to authenticated
  using (
    public.current_caretaker_id() = caretaker_id
  );

-- Polityki RLS dla tabeli świetlic.
alter table public.facilities enable row level security;

drop policy if exists "Public read facilities" on public.facilities;
create policy "Public read facilities"
  on public.facilities
  for select
  to anon, authenticated
  using (true);

drop policy if exists "Caretaker insert facilities" on public.facilities;
create policy "Caretaker insert facilities"
  on public.facilities
  for insert
  to authenticated
  with check (
    public.caretaker_exists(public.current_caretaker_id())
  );

drop policy if exists "Caretaker update facilities" on public.facilities;
create policy "Caretaker update facilities"
  on public.facilities
  for update
  to authenticated
  using (
    exists (
      select 1
      from public.facility_caretakers fc
      where fc.facility_id = id
        and fc.caretaker_id = public.current_caretaker_id()
    )
  )
  with check (
    exists (
      select 1
      from public.facility_caretakers fc
      where fc.facility_id = id
        and fc.caretaker_id = public.current_caretaker_id()
    )
  );

-- Automatyczne przypisanie nowej świetlicy do bieżącego opiekuna.
drop trigger if exists facilities_assign_caretaker on public.facilities;

create or replace function public.assign_caretaker_to_new_facility()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  caretaker uuid;
begin
  caretaker := public.current_caretaker_id();
  if caretaker is null then
    return new;
  end if;

  begin
    insert into public.facility_caretakers (caretaker_id, facility_id)
    values (caretaker, new.id)
    on conflict do nothing;
  exception when others then
    null;
  end;

  return new;
end;
$$;

grant execute on function public.assign_caretaker_to_new_facility() to anon, authenticated;

create trigger facilities_assign_caretaker
  after insert on public.facilities
  for each row
  execute function public.assign_caretaker_to_new_facility();


-- Słownik typów wydarzeń wykorzystywany przy rezerwacjach.
create table if not exists public.event_types (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  description text,
  is_active boolean not null default true,
  order_index integer not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists event_types_active_order_idx
  on public.event_types (is_active desc, order_index, lower(name));

drop trigger if exists event_types_set_updated_at on public.event_types;
create trigger event_types_set_updated_at
before update on public.event_types
for each row execute function public.set_updated_at();

-- Widok publiczny typów wydarzeń.
create or replace view public.public_event_types as
select
  e.id,
  e.name,
  e.description,
  e.order_index
from public.event_types e
where e.is_active;

grant select on table public.public_event_types to anon, authenticated;

-- Szablony dokumentów (wnioski, protokoły, itp.).
create table if not exists public.document_templates (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  code text not null,
  facility_id uuid references public.facilities(id) on delete cascade,
  is_active boolean not null default true,
  html text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create unique index if not exists document_templates_code_facility_unique
  on public.document_templates (lower(code), facility_id);

create unique index if not exists document_templates_code_global_unique
  on public.document_templates (lower(code))
  where facility_id is null;

drop trigger if exists document_templates_set_updated_at on public.document_templates;
create trigger document_templates_set_updated_at
before update on public.document_templates
for each row execute function public.set_updated_at();

-- Rezerwacje świetlic.
create table if not exists public.bookings (
  id uuid primary key default gen_random_uuid(),
  facility_id uuid not null references public.facilities(id) on delete cascade,
  title text not null default 'Rezerwacja',
  event_type_id uuid references public.event_types(id) on delete set null,
  start_time timestamptz not null,
  end_time timestamptz not null,
  renter_name text not null,
  renter_email text not null,
  renter_phone text,
  notes text,
  is_public boolean not null default true,
  status text not null default 'pending' check (status in ('pending', 'active', 'cancelled', 'rejected', 'declined')),
  request_date timestamptz not null default now(),
  decision_comment text,
  cancel_token uuid not null default gen_random_uuid(),
  cancelled_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint bookings_end_after_start check (end_time > start_time)
);

create unique index if not exists bookings_cancel_token_unique
  on public.bookings (cancel_token);

create index if not exists bookings_facility_time_idx
  on public.bookings (facility_id, start_time, end_time);

create index if not exists bookings_status_idx
  on public.bookings (status);

drop trigger if exists bookings_set_updated_at on public.bookings;
create trigger bookings_set_updated_at
before update on public.bookings
for each row execute function public.set_updated_at();

-- Widok uproszczonych danych rezerwacji udostępniany publicznie.
create or replace view public.public_bookings as
select
  b.id,
  b.facility_id,
  b.title,
  b.start_time,
  b.end_time,
  b.status,
  b.renter_name,
  b.notes
from public.bookings b
where b.is_public;

-- Funkcja anulująca rezerwację po tokenie.
create or replace function public.cancel_booking(p_token uuid)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  updated_count integer;
begin
  update public.bookings
  set status = 'cancelled',
      cancelled_at = coalesce(cancelled_at, now()),
      updated_at = now()
  where cancel_token = p_token
    and status in ('pending', 'active');

  get diagnostics updated_count = row_count;
  return updated_count > 0;
end;
$$;

grant execute on function public.cancel_booking(uuid) to anon, authenticated;

grant select on table public.public_bookings to anon, authenticated;

grant insert on table public.bookings to anon;

-- Uprawnienia dla roli authenticated, wymagane do działania polityk RLS i panelu administracyjnego.
grant usage on schema public to authenticated;

grant select, insert, update on table public.caretakers to authenticated;
grant select, insert, update on table public.facilities to authenticated;
grant select, insert, delete on table public.facility_caretakers to authenticated;
grant select, insert, delete on table public.facility_amenities to authenticated;
grant select, insert, update, delete on table public.facility_checklist_items to authenticated;
grant select on table public.amenities to authenticated;
grant select on table public.event_types to authenticated;
grant select, insert, update, delete on table public.document_templates to authenticated;
grant select, insert, update on table public.bookings to authenticated;

grant usage, select on all sequences in schema public to authenticated;
